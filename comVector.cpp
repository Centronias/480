// ****************************************************************************
// ****************************************************************************
// comVector.cpp
// ****************************************************************************
// 
// ****************************************************************************
// ****************************************************************************



// ****************************************************************************
// Includes
// ****************************************************************************
#include "common.h"



// ****************************************************************************
// comVector<T>()
// ****************************************************************************
template <class T>
comVector<T>::comVector()
{
	m_data = new BYTE[sizeof(T)];
	m_numEntries = 0;
	m_size = 1;
}



// ****************************************************************************
// ~comVector<T>()
// ****************************************************************************
template <class T>
comVector<T>::~comVector()
{
	delete [] m_data;
}



// ****************************************************************************
// append()
// ****************************************************************************
template <class T>
void
comVector<T>::append(const T&	element)
{
	if (m_numEntries == m_size) {
		m_size++;
		BYTE*	buf = new BYTE[sizeof(T) * m_size];
		memcpy(buf, m_data, sizeof(T) * m_numEntries);
	}

	m_data[m_numEntries] = element;
}



// ****************************************************************************
// operator[]()
// ****************************************************************************
template <class T>
T&
comVector<T>::operator[](const UINT	index)
{
	return m_data[index];
}

template <class T>
const T&
comVector<T>::operator[](const UINT	index) const
{
	return m_data[index];
}